\documentclass[12pt]{article}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{bibliography}

\usepackage{multicol}

\usepackage{amsfonts}
\usepackage{amsmath}

\usepackage{xcolor}
\usepackage{listings}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{nameref}

\usepackage{lscape}

\usepackage{subfig}


% ------------------------------------------------------------------------------
% tikz
% ------------------------------------------------------------------------------
\usepackage{tikz}
\usetikzlibrary{calc, arrows.meta, positioning, automata, shapes}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
	backgroundcolor=\color{backgroundColour},   
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=C
}

\title{Reachability analysis for continuous one-counter automata}
\author{Lars Van Roy\\
\textit{dept. of Mathematics and Computer Science} \\
\textit{University of Antwerp}\\
lars.vanroy@student.uantwerpen.be}

\begin{document}
\maketitle{}

\begin{abstract}
\noindent
Reachability is a known problem that can heavily affect the efficiency of code. It has been proven that reachability is decidable for continuous one counter timed automata which we will utilise in our approach. The proposed approach will provide a means to convert c code to one counter timed automata followed by an algorithm which is capable of analysing the reachability of each of the nodes within the generated automata. This is an extension to existing research in which we already provided a means to perform the conversion from code to automata. Within this paper, this approach will be repeated here, as the approach is specifically intended to be combined with this predecessor. Finally, we will apply the combination of approaches on an existing code base, as to determine the usefulness of the approach.

\end{abstract}

\newpage
\tableofcontents

\newpage

\section{Introduction}
A well known problem in writing code is the reachability of specific lines in said written code. It is often impossible to properly determine whether or not a line of code guarded by a conditional statement is going to be reachable in any possible execution of the code \cite{713323, 10.1145/1292316.1292319}. Unreachable code is never desired, but is an ever more pressing issue for energy restrained environments such as embedded computer systems \cite{embeddedefficiency}. In these systems, we want our execution to be as efficient as possible, and therefore avoid conditions that can never be satisfied or lines that can never be reached. to remedy this, a proper reachability prevention approach is needed.

To analyse the reachability, we will make use of the fact that code is quit easily convertible to automata. All statements within the code that are related to counter updates can directly be converted to operations within an automaton. Each line of code can represented by one or more nodes and a traversal of an automaton can be directly linked to the traversal of the code itself.

The continuous one counter automata are especially interesting as it has been proven that reachability is decidable for this type of automata \cite{succintandparametriconecounter, danialandjoel, blondin2021continuous}. In this paper we will provide a practical implementation for the theoretical approach that was provided by Tim Leys et al.\cite{blondin2021continuous} which can be used to prove reachability of nodes. 

Adding the restriction of only allowing a single parametric clock has a big effect on the types of code we can analyse. However, this is unavoidable, since there is no proof for two counter machines. Three counter machines and up have been proven to be undecidable \cite{FEARNLEY201526}.

In this paper we will provide the overview of an approach which will convert c code to a one counter automaton. Using the result of this first step, we will then provide a means to analyse the reachability of any of the nodes of said automaton. The following steps are taken without our approach to prove the existence of dead code.

\begin{enumerate}
	\item Convert c code into a parse tree, using ANTLR
	\item Perform context free reductions on this parse tree
	\item Perform context sensitive reductions on this parse tree
	\item Validate the resulting parse tree, to be conforming to the code constraints
	\item Generate the counter automaton
	\item Analyse which nodes are reachable
	\item Link potential unreachable statements back to the lines within the original code base
\end{enumerate}

The code can at most contain one counter and for the continuation of this paper we will only consider examples where this holds. Cases with no counter will not be considered as these are assumed to be trivial. Furthermore, the operations on the counter will be restricted, the counter can only be updated via assignments with parameters or constants, and the counter can only be compared using equality, inequality, strict less than, strict greater than, less than or equal, greater than or equal, and only to parameters or constants. As a final code constraint, the function parameters are not allowed to be altered throughout the duration of the code.

Other then the described code constraint, functions must also have a boolean return type, and integer parameter types (if any) to be converted into a counter automaton.

\section{Motivation}
Popular IDE's do already implement reachability analysis up to a certain degree. However, the dead code elimination they perform is shallow and limited. The code example given below was executed using Clion, one of 

\begin{lstlisting}[style=CStyle]
bool is_mul(int a, int b) {
  int temp = b;
  for(; temp > 0;){
    if(temp == 0){
      break;
    }
    temp -= a;
  }
  return temp == 0;
}

int main() {
  printf("5 is a multiple of 2: %d\n", is_mul(2, 5));
  printf("6 is a multiple of 2: %d\n", is_mul(2, 6));
}
\end{lstlisting}

\noindent
the more commonly used C IDE's. While it is known that Clion can find dead code that directly results from code, it was not able to resolve this case, where the condition on line 4 can never evaluate to true. This is because the for statement on line 3 will always prevent line 4 from evaluating to true and yet Clion did not detect this. 

The approach provided within this paper will be able to detect this, as it can simply evaluate the possible values with which line 5 can be reached, it will result that there is no sequence in which line 5 can be reached and we can therefore conclude that the condition surrounding this statement can never be satisfied.

The impact of removing this line can be significant if considering cases where bigger numbers are passed. In those cases the loop on line 3 will be executed several times, making the condition on line 4 being quit impactful on the total evaluation time of this function. This clearly shows that there is value in enhanced dead code elimination, compared to the current standards. 

\section{Preliminaries}
This paper will make use of counter automata and more specifically one counter automata. These automata are derived from the general definition of automata and signify an extension by adding the notion of counters.

\subsection{General automata}
The automata used in this research are a specific subset of the generally defined automata. The general definition for an automaton A is given by the tuple (Q, $\Sigma$, $\delta$, $q_0$, F) where
\begin{itemize}
	\item Q is the set of states
	\item $\Sigma$ is a finite set of symbols, called the alphabet of the automaton
	\item $\delta: Q \times \Sigma \rightarrow Q$ is the transition function
	\item $q_0 \in Q$ is the initial state
	\item $F \subseteq Q$ is a set of states of Q defining the final states, 
\end{itemize}

\subsection{Continuous one-counter automata}
A continuous one-counter automaton (COCA) is defined as a tuple $\mathcal{A}$ = $(Q, q_0, T, \tau)$ where
\begin{itemize}
	\item $Q$ is a finite set of states
	\item $q_0 \in Q$ is the initial state
	\item $T \subseteq Q \times op \times Q$ is the transition relation with $op$ the set of operations
	\item $I$ is a representation of all intervals over $\mathbb{Q}$
	\item $\tau: Q \rightarrow I$ is the mapping of the reachability intervals
\end{itemize}

At all times the automaton will be in a configuration $(q, c)$ where $q \in Q$ and $c$ the counter valuation where $(q_0, 0)$ is the initial configuration. The counter valuation $c \in \mathbb{N}$ represent one single value for which the counter is evaluated. In our analysis the goal will be to find the range of possible counter values that the counter can have in each state $q \in Q$.

The $\tau$ parameter represents the mapping from all states to the interval of possible counter values that can exist in that state. For example, if a node $q$ has an associated condition stating $\leq 4$ the $\tau$ function would have entry for node $q$ equal to $(-\infty, 4]$. The set of supported constraints within our evaluation are visualised by the $cond$ set below with $\epsilon$ representing the empty condition. Note that this is not binding for the code that we can analyse, several conditions might be convertible to constructs using only supported statements.
\[
cond = \{\leq c, =c, \geq c, \leq p, =p, \leq p: c \in \mathbb{N}, p \in P\} \cup \{\epsilon\}
\]

Parametric counter automata, as compared to regular counter automata, allow counters to be modified by parameters as well as constants. As the counters need to be integers, we will only allow integer type parameters. We will consider the following set of allowed operations where $P$ is the set of parameters, the $\epsilon$ symbol will be used to represent an empty label.
\[
op = \{+c, -c, +p, -p: c \in \mathbb{N}, p \in P\} \cup \{\epsilon\}
\]

The final state is omitted from this definition as we are not interested in this. In general the reachability of every single line of code will be under scope and not a single one of the lines. Furthermore, making the assumption that the final state is the only state of which we want to analyse reachability creates a significant reduction in the use cases of this approach, and was therefore discarded.

\subsection{COCA reachability}
In this section we give an overview of how we approach the concept of reachability. The provided concept was proven by Michael Blonding et al. \cite{blondin2021continuous} and will be the basis for the remainder of the approach.

Throughout the evaluation we will be tracking an interval $I$ which will have $\vert Q \vert$ entries each corresponding to the counter values that can exist within their respective node. 

The concept of reachability will be associated with whether or not a certain node has a non empty interval at the end of the evaluation. A non empty interval automatically implies that the node must be reachable cause if a node can have a counter value, it recursively implies that there must be a path $\pi$ in which all preceding nodes also have non empty intervals.

For this evaluation we will allow transitions to be partially taken. This means that every transition can be scaled by an unknown factor $\alpha \in (0,1]$. This implies that given that we have a preceding interval $[0, 3]$ and an operation $+2$ our resulting interval will not be $[2, 5]$ but rather $(0, 5]$ as with $\alpha \approx 0$ we would remain at zero and with $\alpha = 2$ we would be able to go up to 5. The zero is not included within the resulting interval as we do not allow our $\alpha$ to actually be zero.

The partial aspect of transitions leads to potential false positives. In the example of $[0, 3] + 2 \rightarrow (0, 5]$ we might later on assume that counter values can be 0, which is not necessarily the case. We do however guarantee that in case we decide that a node is not reachable, this does hold. This implies that we may not be able to prove the reachability of every line, but for every line where we can prove it we know for certain that it is correct.

\section{C code to automata conversion}

The approach given within this paper consists out of two major phases. The first phase will consist of the conversion from c code to one counter automata. The second phase will use the result from the first phase, and perform a reachability analysis on these generated automata.

\begin{figure}[t]
	\makebox[\textwidth][c]{
		\begin{tikzpicture}[auto, >=latex, font=\footnotesize\scshape]
		\tikzstyle{center} = [draw=black, rectangle, text width=5.8em]
		
		\node[center]	at (0, 0) 		(q0) 	{Generate tree};
		\node[center]	at (3.5, 0)		(q1)	{Context-free \\optimization};
		\node[center]	at (7, 0)		(q2)	{Context-sensitive \\optimization};
		\node[center]	at (10.5, 0)	(q3)	{Validate conditions};
		\node[center]	at (14, 0)		(q4)	{Generate \\automaton};
		\node[center]	at (14, -2)		(q5)	{Discard \\tree};
		
		\path[draw][->] 
		(q0) edge (q1)
		(q1) edge (q2)
		(q2) edge (q3)
		(q3) edge (q4)
		(q3) edge (q5);
		
		\end{tikzpicture}
	}
\end{figure}

The first phase starts with an initialization, which consists of the generation of a parse tree. This will be done using the default c grammar, with the extension of the boolean type as this is not within the c language by default.

Using the resulting parse tree we will perform a simple context-free optimization where we will remove all needless nodes. This optimization will help us in the third step, where we will do a more in depth optimization cycle. This third cycle will perform optimizations based upon the context in which the nodes appear, and will try to simplify the syntax tree as much as possible. The resulting tree will contain no more potentially ambiguous nodes and all remaining nodes will be those relevant in the remainder of the evaluation.

The fourth step will be an analysis on whether or not the resulting abstract syntax tree conforms to all earlier specified requirements and, if this is the case, we will continue with the fifth step, which will be the generation of the counter automaton. For a function to conform it must have a boolean return value, the arguments (if any) must be of type integer and must never be mutated within the function body, there can only be one counter and the counter can only be mutated using the operations part of the $op$ set displayed below.
\[
op = \{+c, -c, +p, -p, \leq c, =c, \geq c, \leq p, =p, \geq p: c \in \mathbb{N}, p \in P\} \cup \{\epsilon\}
\]

The generation of the automaton within the fifth step is done by traversing the tree and converting every statement that is directly relevant to the counter modifications to their corresponding automaton labels.

\subsection{Initialization}
The program will start of by running the generator ANTLR compilation unit on the given c code. In case there are any issues regarding simple compilation rules, the program will exit with an error, indicating the issues in the code. For the remainder of the execution, the code is assumed to be correct, and there will be no regard for potential issues within the code.

\subsection{Context-free abstract syntax tree generation}
Using the parse tree resulting from the ANTLR compilation, we will try to generate an abstract syntax tree that is as simple as possible without regarding any context. 

First of all, the code uses the notion of a node stack. This node stack will be used to store the nodes that are currently being evaluated.

The first loop will operate as a visitor, which will traverse the parse tree in a depth first manner. The first discovery of a node is done by calling the enter function corresponding to the type of node. As soon as all children of said node have been evaluated, the corresponding exit function will be called. 

However, the creation of nodes is not the same in all situations, in some cases, a specific kind of node will be created, and in other cases a specific kind of node will not be created, depending on the rule used for the current node (which we can determine from the context of the current node). In order to know whether or not we need to pop a node from the node stack, we will allow the code to look at the top node in the stack, and evaluate the type of set node. No other context related evaluations will be allowed.\\
\\
\noindent
\textbf{Context-free analysis assignmentExpression example}\\
To look at a concrete example, consider the following rule in the grammar:
\begin{align*}
	&assignmentExpression\\
	&\text{:}\indent \text{conditionalExpression}\\
	&|\indent \text{unaryExpression assignmentOperator assignmentExpression}\\
	&|\indent \text{Digitsequence}; \\
\end{align*}
The rule for conditionalExpression needs to be there, as there is a chain of expressions, and some expressions need to be higher in the order than others, therefore all expressions with a higher priority need to be evaluated before the lower priority expressions. This is done by adding a rule to a lower priority expression in each expression class. It is however undesirable for these nodes to be added. Without regard for context in other nodes, we can simply look at the current node to see whether or not the conditionalExpression line is used (which ANTLR generated context allows us to do).

Since there is a chance no new node was added within the enter function, we will also be required to evaluate the top of the stack, to see whether or not the top of the stack is a node we need to pop, the code will do the same check that was done in the enter function of the traversal.

\subsection{Context-sensitive abstract syntax tree reduction}
There is still the need for reductions. We will attempt to implement constant propagation and substitution, in which we compute constant expressions, and replace variables with known value, by their actual value. Furthermore we will try to rephrase expressions by expressions with the same meaning, so that all expressions, if possible, are in an acceptable format for the counter automaton.

The context-sensitive reduction will also keep track of a lot of data about the variables in a symbol table. It will track whether or not variables are current initialized with a known value, values at certain points within the execution, it will track struct, union and enum definitions used for folding and so on. It will keep track of the kind of variables we have (eg. counters and parameters). All of this info will be used to enable the operations this cycle will perform, but will also be used in the validation loop.

The program will do this by traversing the abstract syntax tree resulting from the previous step, but will now specifically go through the children of relevant expressions (eg. assignment expressions, additive expressions, ...).

Important to note is that no folding/substitution will occur within loops, as these operations occur a variable number of times, and since there is no way of determining the exact number of times without evaluating the expression, this is considered too complex and often impossible, as counters may depend on parameters, which need to be chosen at evaluation time.\\
\\
\noindent
\textbf{Context-sensitive reduction example: constant propagation}\\
Another example of a needed reduction, is constant propagation and folding. It is possible that a code segment would initially be rejected, due to use of unwanted variables, while in essence, these variables are nothing but variable representations of results of constant expressions. Consider the code snippet below. It would initially be rejected, because the counter variable is initialized with a variable that is neither a constant nor a parameter.

\begin{lstlisting}[style=CStyle]
bool divide(int p, int n){
	int variable = 5;
	variable += 20;
	int counter = variable;
	while(counter > 0){
		counter -= n;
	}
	counter += 1;
	counter -= 1;
	if(counter == 0){
		return true;
	}
	return false;
}
\end{lstlisting}

However, due to constant propagation and folding, we can simplify the two statements on line 2 and line 3, so that they become.

\begin{lstlisting}[style=CStyle]
int variable = 25;
\end{lstlisting}

Now that the variable is just a constant, we can substitute this variable in the declaration of counter, so that we now have the following.
\begin{lstlisting}[style=CStyle]
int variable = 25;
int counter = 25;
\end{lstlisting}

The new code segment is acceptable, but we will not stop here, as the first line of the code is useless. It has no further benefit for the execution and will therefore be dropped. The final counter assignment will not be folded. 

\begin{lstlisting}[style=CStyle]
bool divide(int p, int n){
	int counter = 25;
	while(counter > 0){
		counter -= n;
	}
	counter += 1;
	counter -= 1;
	if(counter == 0){
		return true;
	}
	return false;
}
\end{lstlisting}
\noindent
Whenever a variable gets altered within a conditional scope, the variable is considered to be uncertain, and further folding based on earlier values will not be allowed. The final code segment is as described above, which is trivially accepted to be converted to a counter automaton.\\
\\
\noindent
\textbf{Context-sensitive reduction example: addition folding}\\
As described earlier, we do allow additions and subtractions of the form $-x, +x, -n$ and $+n$, where $x \in P$ or $n \in \mathbb{N}$ with $P$ the set of parameters. Given that the formation, described in Figure \ref{fig:unfolded_addition} occurs in the automaton, we would technically not be allowed to accept this, as this is not directly in the specified format.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{unfolded_addition}
	\caption{An Assignment Expression with counter addition as value.}
	\label{fig:unfolded_addition}
\end{figure}

However, the context-sensitive reduction will be able to reduce the earlier specified example to the automaton in Figure \ref{fig:folded_addition}. This automaton will be acceptable, as this is a direct use of an allowed operation.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\linewidth]{folded_addition}
	\caption{An Assignment Expression with constant as value.}
	\label{fig:folded_addition}
\end{figure}
\newpage
\subsubsection{Nodes}
After the cleaning cycle has finished, there will only be a relatively small set of nodes remaining. Below a quick overview and their meaning within the syntax tree.

\begin{multicols}{2}
	\noindent
	\textbf{Compilation Unit} indicates the root of each Abstract Syntax Tree.\\
	\textbf{Function Definition} indicates the definition of a new function.\\
	\textbf{Function Specifier} indicates specifier of function.\\
	\textbf{Generic} head node for generic specification.\\
	\textbf{Generic Association} indicates a generic association.\\
	\textbf{Parameter Type List} head of the specification of all parameters of a function.\\
	\textbf{Parameter Declaration} head node of the declaration of a single parameter.\\
	\textbf{Compound Statement} indicates a scope defined by \{ \} brackets.\\
	\textbf{Type Specifier} indicates that the child(ren) of this node need to be regarded as being known type(s).\\
	\textbf{Type Name} indicates that the child(ren) of this node need to be regarded as being a type(s).\\
	\textbf{Type Def Name} indicates the definition of a type.\\
	\textbf{Declaration} indicates a declaration, this can contain multiple types and identifiers. In case of a function, the function name and parameter types plus identifiers will all belong to a single declarator node.\\
	\textbf{Init Declarator} defines a declaration of a variable with an initial value.\\
	\textbf{Direct Declarator} defines a declaration of a variable with a second variable.\\
	\textbf{Declarator} head node for the variable name part of the declaration.\\
	\textbf{Initializer} head node for the value part of the declaration.\\
	\textbf{Primary Expression} defines the most basic expression, eg. brackets, identifiers, constants, ... .\\
	\textbf{Postfix Expression} defines a postfix expression.\\
	\textbf{Unary Expression} defines a unary expression.\\
	\textbf{Cast Expression} defines a cast expression.\\
	\textbf{Multiplicative Expression} defines a multiplicative expression.\\
	\textbf{Additive Expression} defines an additive expression.\\
	\textbf{Shift Expression} defines a shift expression.\\
	\textbf{Relational Expression} defines a relational expression.\\
	\textbf{Equality Expression} defines an equality expression.\\
	\textbf{Bitwise And Expression} defines a bitwise and expression.\\
	\textbf{Bitwise Xor Expression} defines a bitwise exclusive or expression.\\
	\textbf{Bitwise Or Expression} defines a bitwise inclusive or expression.\\
	\textbf{Logical And Expression} defines a logical and expression.\\
	\textbf{Logical Or Expression} defines a logical or expression.\\
	\textbf{Conditional Expression} defines a conditional expression.\\
	\textbf{Assignment Expression} defines an assignment expression.\\
	\textbf{Expression} head node in case of multiple expressions.\\
	\textbf{For Declaration} head node for the first clause of a for loop.\\
	\textbf{For Expression} head node for a clause of a for loop.\\
	\textbf{For Condition} head node for the condition part of the second clause of a for loop.\\
	\textbf{Iteration Statement} defines an iteration statement (for, while, do while).\\
	\textbf{Jump Statement} defines a jump statement.\\
	\textbf{return} indicates return statement.\\
	\textbf{Labeled Statement} indicates a labeled statement.\\
	\textbf{Struct or Union Specifier} indicates the specification of a struct or union.\\
	\textbf{Enum Specifier} indicates the specification of an enumerator.\\
	\textbf{Struct Declaration} head node for a struct declaration.\\
	\textbf{Struct Declarator} head node for a struct declarator.\\
	\textbf{Static Assert Declaration} defines static assertion.\\
	\textbf{Enumerator} specifies variables part of an enumerator.\\
	\textbf{Size} head for array size.\\
	\textbf{Default} defines the default option for switch statement.\\
	\textbf{Alignment Specifier} defines an alignment restriction to an identifier.\\
	\textbf{Atomic Type Specifier} defines an atomic type.\\
	\textbf{Arguments} head node for arguments part of a function call.\\
	\textbf{sizeof} defines sizeof operation.\\
	\textbf{\_Alignof} defines \_alignof operation.\\
	\textbf{Val = $<$value$>$} defines a constant. \\
	\textbf{ID = $<$id$>$} defines a variable name.
\end{multicols}

\subsection{Abstract syntax tree validation}
The fourth loop will iterate over the abstract syntax tree resulting from the previous step, and while doing so, it will evaluate the nodes that occur and the context in which they occur.

The majority of the node evaluation is represented in a list of unsupported nodes. Most of these nodes are head nodes for certain kinds of expressions which will never be supported.

\begin{align*}
	unsupported = \left\{ \begin{array}{l}
		Multiplication\ Expression, sizeof, \_Alignof, \\
		\&, *, -, +, ., ->, !, ~, Cast\ Expression, \\
		Shift\ Expression, Bitwise\ And\ Expression, \\
		Bitwise\ Or\ Expression, Bitwise\ Xor\ Expression, \\
		*=, /=, \%=, <<=, >>=, \&=, ^=, |=, \\
		Logical\ And\ Expression, Logical\ Or\ Expression, \\
		Additive\ Expression
	\end{array} \right\}
\end{align*}

Whenever we encounter a node part of the $unsupported$ set, the current situation will be inspected. For example, if a \textit{Multiplication Expression} node occurs, inside a subtree of an \textit{Assignment Expression} node where an assignment to a counter was specified, we know that we are in an invalid state, as counters can only be updated via assignments, additions or subtractions. 

The same logic holds for subtrees of conditional expressions. In case we have a conditional expression where the subtree contains a \textit{Bitwise And Expression} node, we know that this is an invalid state, as constant conditions have already been folded in the previous step, this must mean that there is a counter in the condition, but counter comparisons are not allowed to contain and statements.

Furthermore, all variable usage will be tracked. We will allow multiple counters to exist, as long as we can substitute one general counter without having any conflicts, in other words, there can't be any overlap between counter usages. This is simply tracked by tracking the nodes in which the counter variables occur, with the exception of when they occur within conditional scopes. If this is the case, their first usage is set to the first line of the scope, so that overlap does occur when a different counter is used for the condition of the scope. 

Finally, the initial value will be tracked. In case there is a declaration with an initial value, this value will be chosen, otherwise it will be set to 0, which is the default integer value in C. This initial value allows us to skip over declarations in the generator. We can simply set the counter value to the initial value of the used counter at that point in time, just before its first usage.

Another aspect that will be tested, is the function definition. A function needs to have a boolean return type, and can only have integer parameters. If this not the case, an error status will be added.

These conditions will all be tracked separately for each function. Whenever the status list is empty at the end of the evaluation, we assume that no issues occurred, and we say that the function satisfies the requirements, if there are any issues, no counter automaton will be generated, and the errors will be printed to the terminal.

Important to note is that there is no regard for global statements. These are considered to be variable and undetermined. It could be that they can perfectly be used as counters, and that they will never be altered by other functions, but it is impossible to determine this efficiently. Therefore, a counter must be declared within the function scope.\\
\\
\noindent
\textbf{validation example}\\
When we go back to the earlier mentioned segment of code. We obtain the automaton displayed in Figure \ref{fig:divide_cleaned}.

\begin{lstlisting}[style=CStyle]
bool divide(int p, int n){
	int counter = p;
	
	while(counter > 0){
		counter -= n;
	}
	
	if(counter == 0){
		return true;
	}
	return false;
}
\end{lstlisting}

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{divide_cleaned}
	\caption{The cleaned Abstract Syntax Tree of the divide function.}
	\label{fig:divide_cleaned}
\end{figure}

We can immediately see that the function conforms to the required function definition, as the return type is boolean, as can be seen from the leftmost node. The parameters are also of type int, which can be seen from the parameters defined underneath the 'Parameter Type List' node.

From the cleaner we know which variables are counters, and we can see that the first declaration is a counter, but we will skip the declaration, as we know the value which is stored in the initial value, the initialization will happen before the first operation on the counter occurs. 

Next, we encounter the Iteration statement, for which we will check the condition with the constrained conditional variable enabled. With this variable enabled, we can simply continue traversing the nodes, and in case there are any unsupported nodes, the corresponding error would automatically be generated. However, there will be no corresponding nodes, so we will leave the Relational Expression without any error statuses, and we will disable the constrained conditional variable. 

Next we will enter the compound statement, which symbolizes the inner scope of the iteration statement. We will encounter an Assignment Expression with a variable that we know is a counter, we will therefore enable the counter assignment variable, while traversing the children of this node. No invalid nodes will appear, and we will disable the counter assignment variable when leaving the Assignment Expression node. 

The selection statement will be evaluated in the exact same manner as the Iteration Statement was evaluated, and as the jump statement holds no special operations, we can conclude that this function satisfies the requirements for one counter automaton generation.

\subsection{Counter automaton generation}
\label{sec:generation}
The final section of the program will be the counter generation itself. In this loop, there will be no more regards to possible invalid statements. At this point we assume everything to be known, and we can therefore simplify things drastically. Recall that the following list is the collection of allowed labels for the counter automaton.
\[
op = \{+c, -c, +p, -p, \leq c, =c, \geq c, \leq p, =p, \geq p: c \in \mathbb{N}, p \in P\} \cup \{\wedge\}
\]
This allows us to just check the head nodes related to such expressions.

\subsubsection{Functions}
First of all, we need the notion of the Function Definition statements. The generator will generate a counter automaton for each function, and needs to know when these start.

\subsubsection{Assignments}
Other than functions, we will also need to know when assignments to counters occur, so that we can add the proper transition labels. We only need to check whether or not we are assigning to a counter, if so, we read the operation used, and the variable that gets assigned. Valid counter assignments need to be of the form \textit{c op x} where $c$ is the counter, $op \in $ \textit{\{=, +=, -=\}} and $x \in P \lor x \in \mathbb{N}$. 

As mentioned earlier, assignments are not in the set of operations, but they can be represented using the operators displayed earlier, as can be seen in Figure \ref{fig:counter_assignment}. This can be done by using a reset operation, where we first check whether or not the counter is smaller or equal to the desired value. If so, it is either already satisfied, in which case we can just carry on, or it is smaller than the desired value, for which we will add a self loop with $+1$ as a label, so that we will eventually reach the desired value. 
\begin{figure}[h]
	\centering
	\includegraphics[width=0.48\linewidth]{counter_assignment}
	\caption{Assignment of a value p to a counter.}
	\label{fig:counter_assignment}
\end{figure}

The same thing can be done when the counter is larger or equal to the desired value, if so, it is either already satisfied, in which case we can just carry on, or it is larger than the desired value, at which point we will decrement the counter with a self loop of -1, until the condition is satisfied.

An important thing to remark, is that we are not interested in general properties of runs for these automata. We are interested in the possibility of reachability or in other words, the existence of one path that will take us to a given node. In the given example, there is a path where we would remain in node 3.98 indefinitely but since there is at least one path that would take us to node 4, node 4 is still considered reachable.

\subsubsection{Inequality conditions}
\label{sec:inequality}
Another statement we will need to support, are inequality conditions. If we want our conditional statements to be properly functioning, we will need to be able to generate opposing conditions, but the opposing condition of the equality condition, is the inequality condition, which we can not directly model using the given operations.

The following code segment makes use of an if statement which has an equality condition in it, being the edge going towards the else node.

\begin{lstlisting}[style=CStyle]
bool is_ten(int c){
if(c == 10){
return true;
}

return false;
}
\end{lstlisting}

When looking at part of a simplified counter automaton in Figure \ref{fig:inequality_expression}, we will notice the transitions going from the \textit{start\_if} node, towards the \textit{end\_if} node. There will not be an \textit{else} node, as there is no \textit{else if} or \textit{else} statement.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{inequality_expression}
	\caption{Example of an inequality expression.}
	\label{fig:inequality_expression}
\end{figure}

The first transition chain follows the \textit{lte} nodes, which starts with \textit{c += 1} followed by \textit{c \textless =10}, followed by \textit{c -= 1}, which results in the same expression as saying the original counter is strictly smaller than 10. The final \textit{c -= 1} is there to reset the counter, so that the counter is back to what it originally was. 

The second transition chain follows the \textit{gte} nodes, with the first transition being \textit{c -= 1}, followed by \textit{c \textgreater =10}, followed by \textit{c += 1}. This chain states that the counter must be strictly greater than 10.

If either of these can be taken, we can state that the counter must be different to the compared value (in this case 10), as these both express a strict inequality. 

\subsubsection{Less than and greater than}
\label{sec:strict}
The final addition to the set of supported statements, are the less than and greater than expressions. These are needed to model the opposing conditions to greater than or equal and less than or equal respectively.

\begin{lstlisting}[style=CStyle]
bool is_ten(int c){
	if(c <= 10){
		if(c < 10){
			return false;
		}
		return true;
	}
	return false;
}
\end{lstlisting}

The is\_ten code segment models both a less than or equal condition and a less than condition. The first condition will need to be opposed with a strictly greater than condition, and the second one with a greater than or equal condition.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{less_than_greater_than}
	\caption{Example of a less than expression and a greater than expression.}
	\label{fig:less_than_greater_than}
\end{figure}

A simplified version of the counter automaton of the is\_ten function can be seen in Figure \ref{fig:less_than_greater_than}. This automaton has \textit{start\_if\_1} as the start of the outer if and it has \textit{if\_1} and \textit{end\_if\_1} as respective if and end nodes. The inner if has \textit{start\_if\_2} as the start node, \textit{if\_2} as the start of the if segment, and \textit{end\_if\_2} as the end node.

The strict greater than condition, originating from node \textit{start\_if\_1} and ending in node \textit{end\_if\_1}, consists of 3 different transitions. The first transitions \textit{c -= 1} and \textit{c \textgreater =10}, test if the counter is strictly greater. The third transition \textit{c += 1} is there to make sure that the counter goes back to its original value.

The strict less than condition, originating from node \textit{start\_if\_2} and ending in node \textit{if\_2}, consists of \textit{c += 1} and \textit{c \textless =a} as their first two transitions, which can only be satisfied in case the counter is strictly less than a. The final condition \textit{c -= 1} is there to make sure the counter goes back to its original value.

\subsubsection{Iteration statements}
We will also need the notion of iteration statements, which needs 5 additional special nodes to fully support it's functionality. The first node will be the \textit{start of the loop}. The second node is the \textit{pre node}, this node symbolizes the state after the precondition of the for loop has been evaluated. Next we need a node to identify the \textit{start of the inner segment}, which will be reached by a transition with the condition as a label. 

After this node the inner segment will follow, and it will be finalized with the \textit{stop inner segment} node, in case this one is needed. This stop node will symbolize the state after the post expression of the for loop has been evaluated, after this node, a transition will occur to the pre node, to re-evaluate the loop condition.

Finally, one more node is needed, and this node will symbolize the \textit{end of the loop}. This node will always be the last node that gets generated, so that any nodes generated beyond this point will start from this point.

Consider the following segment of code, this will result in the automaton in Figure \ref{fig:test_counter_automaton}.
\begin{lstlisting}[style=CStyle]
bool test(int c){
	for(c = 0; c < 5; c ++){
		continue;
	}
	return true;
}
\end{lstlisting}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.95\linewidth]{test_counter_automaton}
	\caption{Example of an Iteration Statement.}
	\label{fig:test_counter_automaton}
\end{figure}

\subsubsection{If statements}
\label{sec:if}
Another important construct are the if statements. These statements will, just as the iteration statements did, require additional nodes to be able to be modelled. If statements require a total of 4 nodes to be modelled.

First of all, we need a $start\ if$ node, from which the conditions will start.

We will need an $if$ node and an $else$ node which will both signify the start of the if and possible else segment.

After the inner segment, they will all end up at the $end\ if$ node from which point they will continue with the next line of code.

Consider the test2 function, and the corresponding simplified counter automaton.
\begin{lstlisting}[style=CStyle]
bool test2(int c){
	if(c == 1){
		printf("The counter is equal to 1.");
	}
	else if(c == 2){
		printf("The counter is equal to 2.");
	}
	return true;
}
\end{lstlisting}

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{test2_counter_automaton}
	\caption{Example of if statements.}
	\label{fig:test2_counter_automaton}
\end{figure}

The program will return a more in depth version of the simplified counter automaton displayed in Figure \ref{fig:test2_counter_automaton}. The first if statement will start from $start\_if\_1$, and end at $end\_if\_1$, the else if will start from $start\_if\_2$, and end at $end\_if\_2$.

\subsubsection{Switch statements}
A second conditional statement that exists in c, is a \textit{switch statement}. This statement allows a variable to be compared against multiple values. What is special about the switch statements, is that if matched with one case, the code of all consequential cases will also be executed, until the end of the switch, or until a jump occurs.

Consider the following code snippet. In this case, a variable a will be compared with multiple values, and depending on the matched case, a number of prints will occur.

\begin{lstlisting}[style=CStyle]
bool test(int a){
	switch(a){
		case 3:
			printf("The parameter is greater than 2.");
		case 2:
			printf("The parameter is greater than 1.");
		default:
			printf("The parameter value is %d", a);
	}
	return true;
}
\end{lstlisting}

To generate a counter automaton for a switch statement, we will start by generating a chain for the statements in the cases. This is represented by the chain starting from \textit{start\_switch}, all the way to \textit{default}, in Figure \ref{fig:counter_switch}.

After that we need to add the conditional branches that correspond to the different cases. A first branch originates from \textit{start\_switch}, and can either go to \textit{case\_3} in case the counter is equal to 3, or to \textit{not\_case\_3} in case the counter is not.

There is a second branch from \textit{not\_case\_3} where we can either go to \textit{case\_2} in case the counter is equal to 2, or to \textit{not\_case\_2} in case the counter is not. Finally, from \textit{not\_case\_2} we will always go to the \textit{default} node.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{counter_switch}
	\caption{Example of a switch statement.}
	\label{fig:counter_switch}
\end{figure}

\subsubsection{Counter initialization}
The counters do not get initialized at the point that they got declared within the code. This is a simple improvement that helps to reduce the number of counters. Consider the code segment below, in which two different counters are used.

\begin{lstlisting}[style=CStyle]
bool two_counters(){
	int c = 0;
	int c2 = 0;
	if(c == 2){
		return false;
	}
	else if(c2 == 2){
		return false;
	}
	return true;
}
\end{lstlisting}
The first counter will be initialized just before the if statement gets used. The second counter will not be initialized at that point, but will only be initialized just before the second if statement gets used. This means that the program will in fact be able to support the given code segment, even though it has two different counters.

\subsubsection{Final overview}
To give a in depth overview of how the conversion works, we will transform the following code into a counter automaton. This code consists of multiple if statements, as well as a loop, it makes use of a single counter value, being \textit{counter}, and two parameters. The loop and the final \textit{if} both use inequality expressions, which are representable in a counter automaton, as was described earlier. The first two \textit{ifs} make use of relational expressions with the $<$ and $>$ operators, which are also representable within a counter automaton. The counter is only  using additions or subtractions with parameters and none of these parameters will ever be modified, which also conforms to the requirements. Finally, this function has only integer parameters and a bool return type, which makes us conclude that this entire function is representable in a counter automaton.

\begin{lstlisting}[style=CStyle]
bool gcm(int a, int b){
	int counter = a;
	counter -= b;
	int i1 = 1;
	int i2 = 1;
	while(counter != 0){
		if(counter > 0){
			counter -= b;
			i2 += 1;
		}
		else if(counter < 0){
			counter += a;
			i1 += 1;
		}
		if(counter == 0){
			printf("the greatest multiple is equal to ");
			printf("%d * %d = %d * %d = %d.", i1, a, i2, b, i1*a);
		}
	}
	return true;
}
\end{lstlisting}

The first line is the function definition, this will just be converted to a node with label 1, representing the first line. Since this is the first node added to the counter automaton, it will also be denoted as being the initial node, as can be seen in Figure \ref{fig:final_overview_1}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.2\linewidth]{final_overview_1}
	\caption{First node in the counter automaton.}
	\label{fig:final_overview_1}
\end{figure}

The second line is of interest to the counter machine, as it is a counter modification. However it will not directly generate any special counter automaton configuration, as declarations of counters are only displayed as soon as a counter is actually used or modified. Since nothing special is generated, it will simply generate a new node representing the current line (being 2), with a transition coming from the last added node before this one, as displayed in Figure \ref{fig:final_overview_2}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\linewidth]{final_overview_2}
	\caption{Automaton corresponding to the second line of \textit{gcm}.}
	\label{fig:final_overview_2}
\end{figure}

\newpage

The third line is an actual modification to the counter, so before we generate any additional nodes regarding the operation specified on this line, we need to add the counter initialization as a \textit{pre} statement for this line, this is represented by the tool by decrementing the current line in steps of 0.01. An assignment operation requires three additional nodes, so we will make use of the nodes 2.97, 2.98 and 2.99 to model the assignment functionality, as visualised in Figure \ref{fig:final_overview_3}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{final_overview_3}
	\caption{Counter automaton modelling the initial assignment of the counter.}
	\label{fig:final_overview_3}
\end{figure}

The actual operation specified on line three, is a subtraction of the counter by the parameter b, as is modelled in the sub counter automaton in Figure \ref{fig:final_overview_4}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.35\linewidth]{final_overview_4}
	\caption{Counter automaton modelling the operation on line two.}
	\label{fig:final_overview_4}
\end{figure}

Line four and five are both statements that are not of relevance to the counter, and will therefore be simply represented as a sequential chain following from the last added node, being node 3, as can be seen in Figure \ref{fig:final_overview_5}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{final_overview_5}
	\caption{Counter automaton resulting from line four and five.}
	\label{fig:final_overview_5}
\end{figure}

The sixth line defines a while loop. This requires us to add several nodes that are all related to the statement on line six. The tool will symbolise this by incrementing the current line in steps of 0.01. So 4.01 is a node that is used to help model a statement on line four.

First we need two nodes, one symbolising the start of the inner branch, modelled by the node with label 6.02, and one the symbolise the end of the loop, modelled by the node with label 6.01.

The loop ends as soon as the while condition no longer holds, and therefore the transition from start node, 6, to the end of the loop, 6.01 is a condition checking whether or not the condition of the while loop no longer holds, in this case this condition is represented as equality to zero, being the opposite condition to inequality to zero. 

The loop continues as long as the condition holds, which is modelled by the sequence going from the start node, 6.01, to the start of the inner loop, being 6.02. This configuration models an inequality to zero expression, as described in Section \ref{sec:inequality}, \nameref{sec:inequality}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{final_overview_6}
	\caption{Counter automaton resulting from line six.}
	\label{fig:final_overview_6}
\end{figure}

Lines seven until ten define the first selection statement. Selection statements require, as referenced in Section \ref{sec:if}, \nameref{sec:if}, three additional nodes to fully model the needed implementation.

The start of the selection statement, is modelled by the node with label 7. From this node, there is a transition going to the node with label 7.03, which symbolises the else branch, and therefore the transition to this node symbolises all counter values for which the if condition would not hold, which in this case are all counters smaller than or equal to zero.

The second transition originating from the start of the selection statement symbolises the cases where the counter satisfies the selection condition. The node 7.01 symbolises the start of the inner body of the if statement. The chain of transitions starting from 7 and going to node 7.01 model strict greater than, as is explained in Section \ref{sec:strict}, \nameref{sec:strict}.

Finally, there is the \textit{end of if statement} node, being node 7.02. This node symbolises the end of all branches, so if there were any else branches, they will also end in this node.

The inner body is simple and does not need any complex structures to be added. The statement on line 8 will result in a transition originating from node 8 with label $-= b$. The statement on line 9 has no effect on the counter, and will just be modelled with an empty transition.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{final_overview_7}
	\caption{Counter automaton resulting from line seven up until line ten.}
	\label{fig:final_overview_7}
\end{figure}

The eleventh until fourteenth line models the else branch of the previous selection statement. This statement follows the same design principles as the previous selection statement did, and will be inserted in the previous counter automaton, in the place where the current \textit{else\_branch} label is, as can be seen in Figure \ref{fig:final_overview_8}. Note that there is no else branch, which was not generated as there are not other \textit{else if} or \textit{else} statements in the code.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{final_overview_8}
	\caption{Counter automaton resulting from line eleven up until line fourteen.}
	\label{fig:final_overview_8}
\end{figure}

The final selection statement can be found on line fifteen until line eighteen. This statement includes nothing new, and will simply follow the earlier mentioned specification. This selection statement will end with a transition going from the end of the selection, being the node with label 15.02, to the start of the earlier mentioned while statement, being the node with label 6, as can be seen in Figure \ref{fig:final_overview_9}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{final_overview_9}
	\caption{Counter automaton resulting from line fifteen up until line eighteen.}
	\label{fig:final_overview_9}
\end{figure}

After this, all that remains is the return on line twenty. This return will simply follow after node 6.01 from the while configuration specified earlier. After a return, no nodes will be generated no matter what the kind of these statement is.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.35\linewidth]{final_overview_10}
	\caption{Counter automaton modelling the return on line twenty.}
	\label{fig:final_overview_10}
\end{figure}

The complete overview of the counter automaton can be seen in Figure \ref{fig:final_overview_11}. This is a completely correct counter automaton that is suitable for reachability analysis.

\begin{landscape}
	\begin{figure}
		\centering
		\includegraphics[width=\linewidth]{final_overview_11}
		\caption{Counter automaton modelling the return on line twenty.}
		\label{fig:final_overview_11}
	\end{figure}
\end{landscape}

\subsection{Automaton input}
For the approach described within this paper, an input of an automaton using the dot language part of Graphviz was assumed \cite{10.1007/3-540-45848-4_57}. This language is a very versatile and easily understandable format in which automata can be defined. It was also used as the output language in the preceding research which automatically made it the most interesting format to support. No other formats were considered as the conversion from a textual representation to an instance of the \textit{Automaton} class is not considered to be the core of the research. The logic used for the dot language is furthermore identical to the logic that would need to be applied to read any other automaton specification, with the only difference lying in the language specific aspects of the specification.

\subsubsection{Edge transformation}
Edges are represented within the dot language by a single line per edge using the format specified below. The \textit{origin} and \textit{end} tokens specify the start and end node of the transition. The square brackets encapsulate optional arguments, of which the label and xlabel arguments matter most, as either can be used to specify the label of the transition, and thereby the operation that we want to have attached to the edge. 

\begin{gather*}
	\textless origin \textgreater \rightarrow \textless end\textgreater [label=\textless label\textgreater, xlabel=\textless label\textgreater, ...]
\end{gather*}

This configuration can easily be converted into edge instances, but the labels can still represent several things. To allow any possible automaton specification, we will simply filter the labels using a regex for operations and labels. If it does not match, we assume the label to be an actual name label, if it does match, the label is perceived as a mathematical formula and it will be registered as such. 

To closely match the specification of the theoretical proof on which this approach is based \cite{blondin2021continuous}, we require edges to only contain operations and not conditions. In case an edge is encountered with a condition as a label, this will be resolved by introducing a new node, \textit{inbetween}, to which this condition will be added. This node will be added as an intermediary step and the condition label will be attached to this node. By ensuring that this node will only have one incoming edge and one outgoing edge we preserve the fact that the condition must hold in case one desires to from from the \textit{origin} node to the \textit{end} node. 

Below in Figure \ref{fig:edgetransformlabel} is an example of an edge which does not correspond to the assumptions made within the original paper as the edge between \textit{q0} and \textit{q1} has a conditional label. This is resolved in the image on the right by introducing \textit{\_0} without losing the original meaning of the edge in the first image.

\begin{figure}[h]%
	\centering
	\subfloat{
		\begin{tikzpicture}[auto, >=latex, node distance = 1 cm]
		\tikzstyle{round} = [thick, draw=black, circle, font=\small]
		\tikzstyle{invis} = [draw=none, font=\small]
		
		\node[round] 	at (0, 0) 		(q0) 	{$q0$};
		\node[round] 	at (3, 0)		(q1) 	{$q1$};
		
		\path[->]
		(q0)	edge	node {$>= 0$}	(q1);
		\end{tikzpicture}
	}
	\qquad
	\subfloat{
		\begin{tikzpicture}[auto, >=latex, node distance = 1 cm]
		\tikzstyle{round} = [thick, draw=black, circle, font=\small]
		\tikzstyle{invis} = [draw=none, font=\small]
		
		\node[round] 	at (0, 0) 		(q0) 	{$q0$};
		\node[round] 	at (3, 0)		(q1) 	{$q1$};
		\node[invis]	at (2.3, 2.5)		(q3)	{$>=0$};
		\node[round] 	at (1.5, 2) 	(q4) 	{$\_0$};
		
		\path[->]
		(q0)	edge	node {$ $}	(q4)
		(q4)	edge	node {$ $}	(q1);
		\end{tikzpicture}
	}
	\caption{Transformation of an edge with a conditional label.}
	\label{fig:edgetransformlabel}
\end{figure}

\subsubsection{Node transformation}
Nodes do not require to be specified using a separate node specification rule, and will simply be generated in case they are used within an edge. Node specifications function specifically for the cases in which additional attributes need to be added to nodes. To support operations as well as general labels, the only two attributes which will be tracked from node specification are the \textit{label} and \textit{xlabel} arguments. These labels will be matched with regexes specifying the supported formats for operations and conditions. In case the label does not match either, it is still tracked as regular node labels are still relevant for reachability reporting. For the approach discussed within this paper the node labels represent the code line from which they were generated and are therefore needed to analyse code line reachability. All node specifications will follow the format given below where the square bracket can contain a number of optional arguments.

\begin{gather*}
\textless node \textgreater [label=\textless label\textgreater, xlabel=\textless label\textgreater, ...]
\end{gather*}

To match the specification of the theoretical approach specified by Michael Blondin et Al. \cite{blondin2021continuous}, nodes can only contain conditions and not operations. In case a node \textit{origin} is found that has an operation as its label we introduce a new node \textit{inbetween}. By connecting a new edge from the \textit{origin} node to the \textit{inbetween} node we can add the label that was originally attached to \textit{origin} to the new edge. To ensure that the automaton does not lose any meaning we will then move every edge that would normally go out from \textit{origin} to \textit{inbetween}.

In Figure \ref{fig:nodetransformlabel} below, an example can be seen where node \textit{q1} is not conformant to the original specification. This is resolved by introducing \textit{\_0} from which the edge that was originally going from \textit{q1} to \textit{q2} gets reattached.

\begin{figure}[h]%
	\centering
	\subfloat{
		\begin{tikzpicture}[auto, >=latex, node distance = 1 cm]
		\tikzstyle{round} = [thick, draw=black, circle, font=\small]
		\tikzstyle{invis} = [draw=none, font=\small]
		
		\node[round] 	at (0, 0) 		(q0) 	{$q0$};
		\node[round] 	at (2, 0)		(q1) 	{$q1$};
		\node[invis]	at (2.5, 0.5)	(q3)	{$+1$};
		\node[round] 	at (4, 0) 		(q2) 	{$q2$};
		
		\path[->]
		(q0)	edge	node {$ $}	(q1)
		(q1)	edge	node {$ $}	(q2);
		\end{tikzpicture}
	}
	\qquad
	\subfloat{
		\begin{tikzpicture}[auto, >=latex, node distance = 1 cm]
		\tikzstyle{round} = [thick, draw=black, circle, font=\small]
		\tikzstyle{invis} = [draw=none, font=\small]
		
		\node[round] 	at (0, 0) 		(q0) 	{$q0$};
		\node[round] 	at (2, 0)		(q1) 	{$q1$};
		\node[round] 	at (4, 0) 		(q2) 	{$q2$};
		\node[round] 	at (2, 2) 		(q4) 	{$\_0$};
		
		\path[->]
		(q0)	edge	node {$ $}	(q1)
		(q4)	edge	node {$ $}	(q2)
		(q1)	edge	node {$+1$}	(q4);
		\end{tikzpicture}
	}
	\caption{Transformation of a node with an operational label.}
	\label{fig:nodetransformlabel}
\end{figure}

\subsubsection{Initial node}
For reachability analysis to be relevant there needs to be an initial node. In automata, the initial node is often represented by a transition going from nowhere towards a single node. This is however not a built in feature within the dot language. One of the solutions to overcome this is to create a node and make it invisible, an edge can then be drawn from this invisible node to the actual initial node. Other approaches are potentially possible but were not explored. Any alternative implementations could easily be introduced instead of the considered format without interchanging any of the other components.

As a consequence of this feature invisible nodes are assumed to exist within the automaton but these are irrelevant to our analysis. Invisible nodes are by definition not relevant for reachability analysis and are therefore not considered as actual nodes.

\subsection{Reachability of non parametric COCA}
In this section we will give a description of the solution that was used to determine the reachability for non parametric continuous one counter automata. This will be done by showing the approach that was taken, as well as an application to show its usage. This approach is a practical implementation of the theoretical approach described by Michael Blondin et al. \cite{blondin2021continuous}.

\subsubsection{Initialization}
During the initialization phase, we will instantiate all reachability intervals. The initial node will get an initial reachability interval $[i, i]$ where $i$ represents the initial counter value. This is not a fixed value, but will for the sake of this research always default to 0, simply because all integer values in most programming languages default to 0 at initialization.

All other nodes will get an empty interval assigned to them as to signify that they are initially not reachable.

\subsubsection{Interval updates}
\label{interval updates}
From the initial state, we will start doing cycles in which we update all intervals once, wherever possible. This will be done using the successor function \textit{succ} below where $R_i: Q \times Q \rightarrow 2^\mathbb{Q}$ represent the mapping function for the i-th iteration. This function is going from each transition to its corresponding counter reachability interval. The \textit{succ} function will update the interval of one transition, \textit{(p, z, q)}, to its next iteration, based upon the current configuration.

\begin{gather*}
	\hspace{-134 pt} succ_{p, q}(R_i) := \cup \bigcup \{R_i(q, l)\,|\,(q,z,l) \in T\}\\
	\hspace{60 pt} \cup \bigcup \{(R_i(p, q) + (0, z]) \cap \tau(q)\,|\,(p,z,q) \in T, z>0\}\\
	\hspace{60 pt} \cup \bigcup \{(R_i(p, q) + (z, 0]) \cap \tau(q)\,|\,(p,z,q) \in T, z<0\}\\
	\hspace{-20 pt} \cup \bigcup \{R_i(p, q) \cap \tau(q)\,|\,(p,0,q) \in T\}
\end{gather*}

This formula allows us to iteratively compute the next interval configuration to fully explore which states have a non empty interval. Consider the example given in Figure \ref{fig:example_succ}. We will initialise $R_0$ to have all empty intervals, other than the first which we will initialise to $[0, 0]$. Note that these intervals are stored per pair of final and preceding node and not per node in general. This is because this allows us to have a better tracking of which path has which effect, which will help us in later steps. In the end it suffices to know that a node is reachable, independent on the path via which it can be reached.

\begin{figure}[h]%
	\centering
	\begin{tikzpicture}[auto, >=latex, node distance = 1 cm]
		\tikzstyle{round} = [thick, draw=black, circle, font=\small]
		\tikzstyle{invis} = [draw=none, font=\small]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		
		\node[round] 	at (0, 0) 		(q0) 	{$q_0$};
		\node[round] 	at (3, 0)		(q1) 	{$q_1$};
		\node[round] 	at (6, 0)		(q2) 	{$q_2$};
		\node[invis]	at (7, 0.5)		(q4)	{$\leq 200$};
		\node[round] 	at (9, 0)		(q3) 	{$q_3$};
		\node[invis]	at (10, 0.5)	(q4)	{$\geq 100$};
		
		\path[->]
			(q0) 	edge 					node 					{$+1$}	(q1)
			(q1) 	edge 	[bend left]		node	[right, above] 	{$+1$} 	(q2)
			(q2)	edge 	[bend left]		node	[right, below]	{$+1$}	(q1)
			(q2)	edge 					node					{}		(q3);
	\end{tikzpicture}
	\caption{Example of a guarded automaton on which the succ function can be applied.}
	\label{fig:example_succ}
\end{figure}

\begin{table}[h]
	\begin{tabular}{ |c|c|c|c|c|c|c|c| }
		\hline
		p		& q 	& $R_0$ 		& $R_1$			& $R_2$			& $R_3$			& $R_4$ 		& $R_5$ \\
		\hline
		$q_0$	& $q_0$ & [0, 0] 		& [0, 0] 		& [0, 0] 		& [0, 0]		& [0, 0]		& [0, 0] \\
		$q_0$	& $q_1$ & $\emptyset$ 	& (0, 1]		& (0, 1] 		& (0, 1]		& (0, 1] 		& (0, 1] \\
		$q_1$	& $q_2$ & $\emptyset$ 	& $\emptyset$ 	& (0, 2] 		& (0, 2]		& (0, 4] 		& (0, 4] \\
		$q_2$	& $q_1$ & $\emptyset$ 	& $\emptyset$ 	& $\emptyset$	& (0, 3]		& (0, 3] 		& (0, 5] \\
		$q_2$	& $q_3$ & $\emptyset$ 	& $\emptyset$ 	& $\emptyset$	& $\emptyset$	& $\emptyset$	& $\emptyset$ \\
		\hline
	\end{tabular}
	\centering
	\caption{Decision table for the scenario in which a guest occupies a new cell.}
	\label{table:table_example_succ}
\end{table}

For the first successor, we will only update for the transition going from $q_0$ to $q_1$ as this is the only transition where there is a non empty predecessor. All other transitions will both have an empty interval for the start and ends nodes which will therefore trivially result in empty intervals after applying the succ function. When we apply the succ function on the first interval, we will get $(0, 1]$ as a resulting interval. The 0 is not included as the $(0,z]$ with $z=1$ which we will add to it does not include 0. As $q_1$ has no condition the $\tau(q_1)$ will simply be $(-\infty, \infty)$ and will therefore have no effect.

The second successor will update for the transition going from $q_1$ to $q_2$. This update will be similar to the update that happened for $q_0$ to $q_1$ in every way but the starting interval, which is now (0, 1] and will thus result in an interval of (0, 2].

Next, for the third successor, one would say that we can update both the transition going back form $q_2$ to $q_1$ and the transition going from $q_2$ to $q_3$. However, the latter is not updatable as $R_2(q_2) \cap \tau(q_3)$ will result in an empty set, considering that $\tau(q_3) = [100, \infty)$.

As can be seen in Table \ref{table:table_example_succ} a few more successors were computed and we can clearly notice that we will eventually reach an interval which will exceed the lower bound of 100 which is placed upon $q_3$. Reaching this interval will however take us quite some time, and considering that this is only a small example, this is far from desired. Furthermore, given a loop that is not bounded, it is possible that a loop has no fix point at all, which means that our algorithm will evaluate indefinitely. A solution for this is loop acceleration in which we will accelerate our loop based upon the behaviour said loop shows. 

\subsubsection{Loop acceleration}

Unfortunately, the succ function is not guaranteed to find the bounds in an acceptable number of evaluations. For example, the scenario given in Figure 23 would never converge at all. The interval of the loop between $q_1$ and $q_2$ will keep expanding indefinitely and the evaluation will therefore never stop.

To perform loop acceleration we need to consider the notion of \textit{expanding cycles}. A cycle or loop is considered to be \textit{positively expanding} if there is a path that follows a state sequence $q_i, q_{i+1}, q_{i+2}, ..., q_{n-1}, q_n$ evaluated in reachability iterations $R_0, R_{1}, R_{2}, ..., R_{k-1}, R_{k}$, where k represents the current iteration, such that:
\begin{enumerate}
	\item $q_i = q_n$
	\item $\forall j \in [i, n-1]: (p_j, z_j, q_{j+1}) \in T$
	\item $\forall j \in [i, n-1]: R_k(p_j, q_{j+1}) \ne \emptyset$
	\item $\exists (p, z, q) \in T: z > 0$
	\item $sup(R_k(q_{n-1}, q_{n})) > sup(R_{k-1}(q_{n-1}, q_n))$
\end{enumerate}

Similarly we say that a cycle is \textit{negatively expanding} if the following hold:
\begin{enumerate}
	\item $q_i = q_n$
	\item $\forall j \in [i, n-1] : (p_j, z_j, q_{j+1}) \in T$
	\item $\forall j \in [i, n-1]: R_k(p_j, q_{j+1}) \ne \emptyset$
	\item $\exists (p, z, q) \in T: z < 0$
	\item $inf(R_k(q_{n-1}, q_{n})) < inf(R_{k-1}(q_{n-1}, q_n))$
\end{enumerate}

The first condition in combination with the second condition simply implies that we require there to be an actual loop. The third condition states that we should have visited every transition at least once. In case we did not we have insufficient information needed to perform the acceleration and we will therefore only mark loops as expanding in case we have fully discovered it. This also eliminates the potential that we are looking at loops where some of the nodes are not reachable due to node constraints present within the loop. The fourth and fifth condition are there to ensure that there is an actual expansion. If only the fifth condition holds, it implies that there was a change in supremum due to something outside of the loop, in case only the fourth condition holds but not the fifth, it implies that we have already reached the bound of the loop. In the latter case the loop will not be marked as expanding as this implies that it reached its bound after one iteration.

Given that we know whether or not a cycle is either positively or negatively expanding, we can derive which node will reach its bound first. By doing so we can move the interval to this bound and thus greatly accelerating the evaluation of said loop. By performing one more iteration throughout the loop, all bounds would be reached and no further evaluation of the before mentioned loop will be needed.

To find the node who will be the first to reach a fix point interval, we can simply consider the node for which the current reachability interval's supremum/infimum is closest to the max/min node bound given that we are either trying to accelerate upwards or downwards respectively. In the formula below $reach(q)$ represents a function denoting the set of final counter values for a state $q$ and $\underline{\tau}(q_j)$ and $\overline{\tau}(q_j)$ represent the upper and lower node bounds of node $q_j$ respectively.\\
\\
\noindent
Given a loop that is expanding positively. If the following properties evaluate to true:

\begin{itemize}
	\item $sup(R_i) > sup(R_n)$
	\item $\exists (p, z, q) \in T: z > 0$
	\item $\overline{\tau}(q_k) - v_k = min_{i\leq j \le n}\,\overline{\tau}(q_j) - v_j$
\end{itemize}
The following property will apply:
\begin{itemize}
	\item $[v_k, \overline{\tau}(q_k)] \subseteq reach(q_k)$
\end{itemize}


\noindent
Given a loop that is expanding negatively. If the following properties evaluate to true:

\begin{itemize}
	\item $inf(R_i) < inf(R_n)$
	\item $\exists (p, z, q) \in T: z < 0$
	\item $v_k - \underline{\tau}(q_k) = min_{i\leq j \le n}\,v_j - \underline{\tau}(q_j)$
\end{itemize}
The following property will apply:
\begin{itemize}
	\item $[\underline{\tau}(q_k), v_k] \subseteq reach(q_k)$
\end{itemize}

In our approach this allows us to traverse the differences between the previous iteration and the current iteration whenever we update a node that we already have an interval for. Given the example that was explored in Section \nameref{interval updates} we can see that we have a loop going from $q_1$ to $q_2$ and back. 

\begin{table}[h]
	\begin{tabular}{ |c|c|c|c|c|c|c|c| }
		\hline
		p		& q 	& $R_0$ 		& $R_1$			& $R_2$			& $R_3$			& $R_4$ 		& $R_5$ \\
		\hline
		$q_0$	& $q_0$ & [0, 0] 		& [0, 0] 		& [0, 0] 		& [0, 0]		& [0, 0]		& [0, 0] \\
		$q_0$	& $q_1$ & $\emptyset$ 	& (0, 1]		& (0, 1] 		& (0, 1]		& (0, 1] 		& (0, 1] \\
		$q_1$	& $q_2$ & $\emptyset$ 	& $\emptyset$ 	& (0, 2] 		& (0, 2]		& (0, 4] 		& (0, 4] \\
		$q_2$	& $q_1$ & $\emptyset$ 	& $\emptyset$ 	& $\emptyset$	& (0, 3]		& (0, 3] 		& (0, 5] \\
		$q_2$	& $q_3$ & $\emptyset$ 	& $\emptyset$ 	& $\emptyset$	& $\emptyset$	& $\emptyset$	& $\emptyset$ \\
		\hline
	\end{tabular}
	\centering
	\caption{Resulting interval configuration in case acceleration is not applied.}
	\label{table:table_example_no_acc}
\end{table}

In Table \ref{table:table_example_no_acc} we can see that in the third reachability interval, $R_2$, a counter value interval is discovered for the transition going from $q_1$ to $q_2$. In the next reachability interval the same happens for $q_2$ to $q_1$. In $R_4$ we will once again update the interval for the transition going from $q_1$ to $q_2$ which will result in all conditions for a positive expanding loop evaluating to true. This is because we have a loop of which we know that the supremum of one of the transitions just increased and we have a transition part of this loop with a strictly positive operation.

Applying our previously described steps, we will find that node $q_2$ is closest to its bound and we will therefore choose to expand the interval of the transition ending in this node, being the transition from $q_1$ to $q_2$. The result is shown in Table \ref{table:table_example_acc}.

\begin{table}[t!]
	\begin{tabular}{ |c|c|c|c|c|c|c|c| }
		\hline
		p		& q 	& $R_0$ 		& $R_1$			& $R_2$			& $R_3$			& $R_4$ 		& $R_5$ \\
		\hline
		$q_0$	& $q_0$ & [0, 0] 		& [0, 0] 		& [0, 0] 		& [0, 0]		& [0, 0]		& [0, 0] \\
		$q_0$	& $q_1$ & $\emptyset$ 	& (0, 1]		& (0, 1] 		& (0, 1]		& (0, 1] 		& (0, 1] \\
		$q_1$	& $q_2$ & $\emptyset$ 	& $\emptyset$ 	& (0, 2] 		& (0, 2]		& (0, 200] 		& (0, 200] \\
		$q_2$	& $q_1$ & $\emptyset$ 	& $\emptyset$ 	& $\emptyset$	& (0, 3]		& (0, 3] 		& (0, 201] \\
		$q_2$	& $q_3$ & $\emptyset$ 	& $\emptyset$ 	& $\emptyset$	& $\emptyset$	& $\emptyset$	& [100, 200] \\
		\hline
	\end{tabular}
	\centering
	\caption{Resulting interval configuration after acceleration.}
	\label{table:table_example_acc}
\end{table}

If we do one additional iteration, we can see that we have now discovered an interval for the transition going from $q_2$ to $q_3$. We have furthermore achieved a fix point, as both $q_2$ and $q_3$ have met their bounds.

\subsubsection{Proof of termination}
This algorithm will always terminate. Given that there are no loops it will trivially terminate within n evaluations, given that n is equal to the total number of nodes within the automaton. If there are loops they must either be positively expanding, negatively expanding or not expanding at all. In the last case the simulation will trivially terminate as the loops will end in a fix point after their first evaluation. If they are expanding, we have shown that we are capable of accelerating them after which one additional evaluation will always make them reach their bounds. 

\begin{figure}[b!]%
	\centering
	\begin{tikzpicture}[auto, >=latex, node distance = 1 cm]
		\tikzstyle{round} = [thick, draw=black, circle, font=\small]
		\tikzstyle{invis} = [draw=none, font=\small]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		
		\node[round] 	at (0, 0)		(q1) 	{$q_0$};
		\node[round] 	at (-3, 0)		(q2) 	{$q_1$};
		\node[invis]	at (-3, 0.75)	(q3)	{$\leq 200$};
		\node[round] 	at (3, 1)		(q4) 	{$q_2$};
		\node[invis]	at (3, 1.5)		(q5)	{$\leq 200$};
		\node[round] 	at (3, -1)		(q6) 	{$q_3$};
		
		\path[->]
		(q1) 	edge 	[bend left]		node	[right, above] 	{$+2$} 	(q2)
		(q2)	edge 	[bend left]		node	[right, above]	{$+2$}	(q1)
		(q1) 	edge 	[bend left]		node 	[right, below]	{$-1$}	(q4)
		(q4) 	edge 	[bend left]		node	[right]		 	{$-1$} 	(q6)
		(q6)	edge 	[bend left]		node	[right, above]	{$-1$}	(q1);
	\end{tikzpicture}
	\caption{Example of an automaton in which post acceleration evaluation is needed.}
	\label{fig:example_recomputation_of_bounds}
\end{figure}

It is possible that further evaluations require bounds to be recomputed. For example, given the automaton described in Figure \ref{fig:example_recomputation_of_bounds}. In this automaton the loop between $q_0$ and $q_1$ will be expanded first. The second loop will still get evaluated and the lower bound of $q_0$ to $q_1$ will keep on decreasing, until the second loop will get accelerated, at which point a fix point will be achieved and the evaluation will end. This will always be the case given that we will always have a finite amount of nodes which will thus result in a finite amount of loops which will all accelerate at some point. The effects of said acceleration might need a few more evaluations to propagate their effect all across the automaton but once it does the evaluation will end. We can therefore conclude that the algorithm can never run indefinitely.

A mathematical proof for the the theoretical algorithm on which this approach is based is given in the paper by Michael Blondin et al. \cite{blondin2021continuous}. This paper will prove that this algorithm will always terminate, and will do so in at most $(4\vert Q\vert ² + 5\vert Q\vert)$ accelerations.

\subsection{Reachabiltiy of parametric COCA}
Throughout this section we will give an overview of how the reachability for parametric continuous one counter automata can be analysed. This will be done using the approach that was theoretically described by Michael Blondin et al. \cite{blondin2021continuous}. This paper will both give a practical approach as well as an application, intended as prove that it works in practise.

In this approach we will attempt to fully convert the automaton as well as the reachability problem to a SAT problem. This can then automatically be resolved by existing solutions which will simply traverse all possible variable assignments until a solution is found.

\subsubsection{Transition initialization}
During initialization we will start by converting all transitions that are defined within the given automaton to their equivalent equations. All transitions are represented by three variables. Two variables are used to represent that start and end point of the transition and the third will represent the operation associated with the transition. The operation will simply be an integer value as we limited our automata to only allow + and - operations. This means that an integer can fully cover every possible operation that can be performed on an edge. Note that there is no need to cover conditions on edges as we resolved all inconsistencies regarding transitions with conditional labels in our automaton input phase. This value can also be a parameter in which case our SAT solver will be allowed to choose any value for which this evaluation would eventually evaluate to true. The signs are simply added to the variable and no further limitations are emplaced upon the variable other than the requirement that these variables must be integers.

Alongside the transitions we will also initialise the conditions of the nodes in which the transitions end. These are important as these decide whether or not a transition can be taken. Given that we have a transition with an operation equal to $+1$, a current counter value equal to just $0$ and an end node with a condition equal to $\le -1$ we are not allowed to take this edge. Each condition will be represented by two variables, one to indicate the condition type and a second to indicate the value against which it is compared. Note that we will both allow this value to be parametric or a constant. The condition type can have three different values, $0$ will be used to represent the $\ge$ operation, $1$ will be used to represent $\le$, 2 will represent $=$ and finally $3$ will be used in case there is no condition associated with the end node.

Finally, now that we have converted all this information, we can start to model the transition sequences. To do this we will create an $or$ chain in which every option is represented by a 5 variable $and$ statement. The $and$ will represent the chosen transition, represented by 3 variables and the condition of the end node, represented by 2 variables. The assignment of values to unknowns will be done by equality conditions thus requiring that a variable is equal to the expected value in case we would like this transition to be taken. Every transition will be converted to an $and$ and subsequently added as an option to the big $or$. This $or$ will be generated n times, where n represents the total number of nodes. This allows us to easily prove whether or not a node is reachable directly, without considering any loops. 

\begin{figure}[b!]%
	\centering
	\begin{tikzpicture}[auto, >=latex, node distance = 1 cm]
		\tikzstyle{round} = [thick, draw=black, circle, font=\small]
		\tikzstyle{invis} = [draw=none, font=\small]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		
		\node[round] 	at (0, 0) 		(q0) 	{$q_0$};
		\node[round] 	at (3, 0)		(q1) 	{$q_1$};
		\node[round] 	at (6, 0)		(q2) 	{$q_2$};
		\node[invis]	at (7, 0.5)		(q4)	{$\leq b$};
		\node[round] 	at (9, 0)		(q3) 	{$q_3$};
		\node[invis]	at (10, 0.5)	(q4)	{$\geq 100$};
		
		\path[->]
		(q0) 	edge 					node 					{$+1$}	(q1)
		(q1) 	edge 					node 					{$+a$}	(q2)
		(q2)	edge 					node					{}		(q3);
	\end{tikzpicture}
	\caption{Example of a parametric guarded automaton on which the SAT solver can be applied.}
	\label{fig:example_param_guarded}
\end{figure}

In the example given in Figure \ref{fig:example_param_guarded} we can see an example automaton for which the preceding reachability analysis algorithm would not be suitable. It has two parameters being the parameter $a$ used in an addition on the centre transition and the variable b, used as a condition on the $q_2$ node after said transition.

We would start the analyse by storing the different values associated with each transition. This would result in the table below where the index represents the place of the edge within the graph, starting from left to right.

\begin{table}[h]
	\begin{tabular}{ |c|c|c|c|c|c| }
		\hline
		index				& start 		& op			& end			& cond type				& cond value\\
		\hline
		0					& $q_0$ 		& $+1$			& $q_1$ 		& $3$						& $none$	\\
		1					& $q_1$ 		& $+a$			& $q_2$ 		& $1$						& $b$ 		\\
		2					& $q_2$	 		& $none$ 		& $q_3$ 		& $0$						& $100$  \\
		\hline
	\end{tabular}
	\centering
	\caption{Resulting configuration for the different transitions.}
	\label{table:table_example_transition mapping}
\end{table}

To convert this table to a option within the bigger or we use an and which uses the format given below. In this format i represent the step of the traversal, so in other words $i = 0$ would imply that this is the firs transition we take, $i = 1$ the second transition and so on. For each i the 5 variables shown below will constantly be reused as they must specifically match one of the transitions. The right hand sides of the operations will be filled in with the respective values of each transition. So we will have a chain of $and$ statements for the first transition, one for the second and one for the third. 

\begin{gather*}
	t_{i_0} = start \land t_{i_1} = op \land t_{i_2} = end \land c_{i_0} = cond\;type \land c_{i_0} = cond\;value
\end{gather*}

For the continuation of this example consider $SELECT(t_j, i)$ to represent the filled in formula for the j-th transition and the i-th step. This new notation allows us to generate the formula below which shows the formula that describes all options from which the SAT solver can choose for the first transition.

\begin{gather*}
	SELECT(t_0, 0) \lor SELECT(t_1, 0) \lor SELECT(t_2, 0)
\end{gather*}

Now that we have the formula for the first transition, all that is left is to consider the selection of all transitions rather than just the first. To simplify the notation, assume that the formula above is represented by $STEP(i)$ where i indicates the step we are generating the formula for. This allows us to construct the final sequence below in which we will have a finished formula in which we need to select one transition per step in order to make it evaluate to true. The variables which are used as left hand sides in the equations will all have a value and will be used for comparisons and verifications in the remainder of this evaluation. Note that we only considered three different steps, which is equal to the number of nodes minus 1. If we are not considering any loops the algorithm must be able to terminate in that many steps or there is no solution at all. It is very important to limit the number of equations as a large amount of equations can greatly increase the solve time of the SAT solver. 

\begin{gather*}
	STEP(0) \land STEP(1) \land STEP(2)
\end{gather*}

\subsubsection{Interval initialization}
The intervals used in the previous section will be converted to equations by using 4 different variables. The first  two variables will represent the lower and upper bound using their actual integer values. The two last variables will represent whether or not the upper and lower bound are inclusive where a 1 implies inclusive and a 0 implies not inclusive. A value of 2 implies that its corresponding limit is equal to infinity.

At initialization we will start by defining and storing the variables for each of the interval we will encounter. This means $4 * n$ variables per step and $n$ steps, with n representing the total number of nodes. 

During the initialization we will also assign values to the first step, being a $[0, 0]$ interval for the first node (represented by the values $0, 0, 1, 1$) or a $(0, 0)$ interval (i.e. an empty interval) for all other nodes. This assignment will be done using the equation below where i represents the step and j represents the node, for this example the values for the assignment of the initial node was used.

\begin{gather*}
	v_{i_{j_0}} = 0 \land v_{i_{j_1}} = 0 \land v_{i_{j_2}} = 1 \land v_{i_{j_3}} = 1
\end{gather*}

\subsubsection{Defined the end goal}
We want to determine the reachability of a certain node within an automaton. It is therefore vital that we specifically deduce whether or not said node is indeed reachable which can be done by requiring that there is a transition with an end node $t_{i_2}$ equal to the desired node $g$ for which the equation can be seen below. Note that we also define a variable n equal to the current step i. This is done because later on we want to disable certain requirements in case the goal node has already been reached.

\begin{gather*}
	t_{i_2} = g \land n = i
\end{gather*}

Using the equation above we can simply define the end condition by saying that for one of the transitions the above must hold, as can be seen below.

\begin{gather*}
	(t_{0_2} = g \land n = 0) \lor (t_{1_2} = g \land n = 1) \lor (t_{2_2} = g \land n = 2) \lor ...
\end{gather*}

\subsubsection{Define the start of the path}
We need to add a constraint that requires us to start from the initial node. Otherwise it might be possible for us to take transitions somewhere completely random within our automaton as a starting point which is not acceptable. This constraint will simply require the $t_{0_0}$ variable, representing the start of the first selected transition, to be equal to the initial node.

\begin{gather*}
	t_{0_0} = \text{\textless initial node\textgreater}
\end{gather*}

\subsubsection{Sequential transitions}
The last condition we need to enforce is the need for the transitions to end where the next one starts. This is done by enforcing the condition below for every step in the evaluation. 

\begin{gather*}
	t_{i_2} = t_{i+1_0}
\end{gather*}

\subsubsection{msum}
The msum function is used to determine the inclusiveness of the bounds in the interval addition. The msum function is defined as:

\begin{gather*}
msum(i, j) = 2 \qquad \qquad if \; max(i,j) = 2 \\
msum(i, j) = min(i, j) \quad \qquad \quad otherwise \qquad \qquad \qquad
\end{gather*}

\subsubsection{Emptiness of intervals}
We need to be able to verify whether or not an interval is empty in order to create base cases for future operations. An interval is considered to be empty if both bounds are not inclusive and the boundary values are equal to each other as can be seen in the formulae below. Note that we do not check whether or not the lower bound is higher than the higher bound (in which case it would also be empty). This is not needed as such a situation can never be reached. All transitions can only expand intervals and never reduce due to us allowing transitions to be taken partially.

\begin{gather*}
	x_2 = 0 \\
	x_3 = 0 \\
	x_0 = x_1
\end{gather*}

\subsubsection{Interval addition}
The addition of intervals will be split in three different cases as can be seen in the graph below. In case either operand is an empty interval the resulting interval will trivially equal the other interval. In case they are both not empty we compute the sum by taking the addition of the lower and upper bound of the X and Y intervals and the msum to compute whether or not the resulting bounds are inclusive.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[auto, >=latex, font=\footnotesize\scshape]
		\tikzstyle{small} = [draw=black, rectangle]
		\tikzstyle{center} = [draw=black, rectangle, text width=8em, align=center]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		
		\node[center]	at (-0.5, 0) 	(q0) 	{Z = X + Y};
		
		\node[center]	at (2, -1) 		(q1) 	{X is empty};
		\node[center]	at (2, -2)		(q2)	{Y is empty};
		\node[center]	at (2, -3)		(q3)	{X,Y is not empty};
		
		\node[center] 	at (6.5, -1)	(q4)	{$Z = Y$};
		\node[center] 	at (6.5, -2)	(q5)	{$Z = X$};
		\node[center] 	at (6.5, -3.6)	(q6)	{$Z_0 = X_0 + Y_0$ \\
												 $Z_1 = X_1 + Y_1$ \\
												 $Z_2 =$ msum$(X_2 + Y_2)$ \\
												 $Z_3 =$ msum$(X_3 + Y_3)$};
		
		\draw [arrow] (q0) |- (q1);
		\draw [arrow] (q0) |- (q2);
		\draw [arrow] (q0) |- (q3);
		
		\draw [arrow] (q1) |- (q4);
		\draw [arrow] (q2) |- (q5);
		\draw [arrow] (q3) |- (q6);
	\end{tikzpicture}
\end{figure}

\subsubsection{Interval overlap}
One important relationship between two intervals is overlap as it directly helps to simplify the generation of unions and intersections of intervals. This can be computed by verifying whether or not any of the endpoint of one interval is within the other interval. Note that it is important to specifically look at the third and fourth variable part of the interval to also consider infinite bounds.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[auto, >=latex, font=\footnotesize\scshape]
		\tikzstyle{small} = [draw=black, rectangle]
		\tikzstyle{center} = [draw=black, rectangle, text width=8em, align=center]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		
		\node[center]	at (-0.5, 0) 	(q0) 	{X overlaps Y};
		
		\node[center]	at (2, -1)		(q3)	{$X_0$ inside Y};
		\node[center]	at (2, -2)		(q4)	{$X_1$ inside Y};
		\node[center]	at (2, -3)		(q5)	{$Y_0$ inside X};
		\node[center]	at (2, -4)		(q6)	{$Y_1$ inside X};
		
		\draw [arrow] (q0) |- (q3);
		\draw [arrow] (q0) |- (q4);
		\draw [arrow] (q0) |- (q5);
		\draw [arrow] (q0) |- (q6);
	\end{tikzpicture}
\end{figure}


\subsubsection{Interval intersection}
The entirety of the intersection operation is visualised in Image \ref{fig:intersection} below. In this image all nodes where multiple lines leave are assumed to imply $or$ operations between all end nodes. This holds with the exception of the coloured nodes where nodes of the same colour represent an $or$ operation which will then be combined in a bigger $and$.

For the intersection of intervals we will first of all consider the cases where the result is an empty vector. This can either occur when there is no overlap or when X or Y is empty. In any of these cases we can simply assign an empty vector to Z, being the resulting interval.

If this is not the case we will separately evaluate both borders of the interval. The lower border is represented by the red colour and the upper border by the blue colour within Image \ref{fig:intersection}. 

For both sides it hold that if either X or Y goes to infinity in that direction than Z will have the boundary values of the other interval. For example if X would go to infinity on the lower bound then the value of Z will be equal to the value of Y for both the lower bound value and whether or not this bound is inclusive.

\begin{figure}
	\centering
	\begin{tikzpicture}[auto, >=latex, font=\footnotesize\scshape]
		\tikzstyle{center} = [draw=black, rectangle, text width=5.5em, align=center]
		\tikzstyle{centert} = [draw=black, rectangle, text width=5.5em, align=center, text=red]
		\tikzstyle{centerb} = [draw=black, rectangle, text width=5.5em, align=center, text=blue]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		
		\node[center]	at (0, 8) 		(q0) 	{$Z = X \cap Y$};
		\node[center]	at (0, 3.8)		(q4)	{else};
		
		\node[center]	at (1.6, 7)		(q1)	{no overlap};
		\node[center]	at (1.6, 6) 	(q2) 	{X is empty};
		\node[center]	at (1.6, 5)		(q3)	{Y is empty};
		
		\node[centert]	at (1.6, 2.4)	(q6)	{$X_2 \ne 2$ $\land$ \\ $X_2 \ne 2$};
		\node[centerb]	at (1.6, -5.2)	(q7)	{$X_3 \ne 2$ $\land$ \\ $X_3 \ne 2$};
		
		\node[center]	at (4.5, 7)		(q9)	{$Z = [0, 0, 1, 1]$};
		\node[center]	at (4.5, 6)		(q10)	{$Z = [0, 0, 1, 1]$};
		\node[center]	at (4.5, 5)		(q11)	{$Z = [0, 0, 1, 1]$};
		\node[centert]	at (4.5, 3.8)	(q12)	{$X_2/Y_2 = 2$};
		\node[center]	at (4.5, 2.4)	(q14)	{$X_0 < Y_0$};
		\node[center]	at (4.5, 1.1)	(q15)	{$Y_0 < X_0$};
		\node[center]	at (4.5, -0.2)	(q16)	{$X_0 = Y_0$};
		\node[centerb]	at (4.5, -3.9)	(q13)	{$X_3/Y_3 = 2$};
		\node[center]	at (4.5, -5.2)	(q17)	{$X_1 > Y_1$};
		\node[center]	at (4.5, -6.5)	(q18)	{$Y_1 > X_1$};
		\node[center]	at (4.5, -7.6)	(q19)	{$X_1 = Y_1$};
		
		\node[center]	at (7.5, 3.8)		(q32)	{$Z_0 = X_0/Y_0$ $\land$ \\ $Z_2 = X_2/Y_2$};
		\node[center]	at (7.5, 2.4)		(q22)	{$Z_0 = Y_0$ $\land$ \\ $Z_2 = Y_2$};
		\node[center]	at (7.5, 1.1)		(q23)	{$Z_0 = X_0$ $\land$ \\ $Z_2 = X_2$};
		\node[center]	at (7.5, -0.2)		(q24)	{$X_2 = 0$};
		\node[center]	at (7.5, -1.5)		(q25)	{$Y_2 = 0$};
		\node[center]	at (7.5, -2.8)		(q26)	{$X_2 = Y_2 = 1$};
		\node[center]	at (7.5, -3.9)		(q33)	{$Z_1 = X_1/Y_1$ $\land$ \\ $Z_3 = X_3/Y_3$};
		\node[center]	at (7.5, -5.2)		(q27)	{$Z_1 = Y_1$ $\land$ \\ $Z_3 = Y_3$};
		\node[center]	at (7.5, -6.5)		(q28)	{$Z_1 = X_1$ $\land$ \\ $Z_3 = X_3$};
		\node[center]	at (7.5, -7.6)		(q29)	{$X_3 = 0$};
		\node[center]	at (7.5, -8.9)		(q30)	{$Y_3 = 0$};
		\node[center]	at (7.5, -10.2)		(q31)	{$X_3 = Y_3 = 1$};
		
		\node[center]	at (10.5, -0.2)	 (q35)	{$Z_0 = X_0$ $\land$ \\ $Z_2 = 0$};
		\node[center]	at (10.5, -1.5)	 (q36)	{$Z_0 = Y_0$ $\land$ \\ $Z_2 = 0$};
		\node[center]	at (10.5, -2.8)	 (q37)	{$Z_0 = X_0$ $\land$ \\ $Z_2 = 1$};
		\node[center]	at (10.5, -7.6)	 (q38)	{$Z_1 = X_1$ $\land$ \\ $Z_3 = 0$};
		\node[center]	at (10.5, -8.9)	 (q39)	{$Z_1 = Y_1$ $\land$ \\ $Z_3 = 0$};
		\node[center]	at (10.5, -10.2) (q40)	{$Z_1 = X_1$ $\land$ \\ $Z_3 = 1$};
		
		\draw [arrow] (q0)  -- (q4);
		
		\draw [arrow] (q0)  |- (q1);
		\draw [arrow] (q0)  |- (q2);
		\draw [arrow] (q0)  |- (q3);
		
		\draw [arrow] (q4)  |- (q6);
		\draw [arrow] (q4)  |- (q7);
		
		\draw [arrow] (q1)  |- (q9);
		\draw [arrow] (q2)  |- (q10);
		\draw [arrow] (q3)  |- (q11);
		\draw [arrow] (q4)  |- (q12);
		\draw [arrow] (q4)  |- (q13);
		\draw [arrow] (q6)  |- (q14);
		\draw [arrow] (q6)  |- (q15);
		\draw [arrow] (q6)  |- (q16);
		\draw [arrow] (q7)  |- (q17);
		\draw [arrow] (q7)  |- (q18);
		\draw [arrow] (q7)  |- (q19);
		
		\draw [arrow] (q12) |- (q32);
		\draw [arrow] (q13) |- (q33);
		\draw [arrow] (q14) |- (q22);
		\draw [arrow] (q15) |- (q23);
		\draw [arrow] (q16) |- (q24);
		\draw [arrow] (q16) |- (q25);
		\draw [arrow] (q16) |- (q26);
		\draw [arrow] (q17) |- (q27);
		\draw [arrow] (q18) |- (q28);
		\draw [arrow] (q19) |- (q29);
		\draw [arrow] (q19) |- (q30);
		\draw [arrow] (q19) |- (q31);
		
		\draw [arrow] (q24) |- (q35);
		\draw [arrow] (q25) |- (q36);
		\draw [arrow] (q26) |- (q37);
		\draw [arrow] (q29) |- (q38);
		\draw [arrow] (q30) |- (q39);
		\draw [arrow] (q31) |- (q40);
		
	\end{tikzpicture}
	\caption{Overview of the interval intersection operation.}
	\label{fig:intersection}
\end{figure}

If neither X or Y goes to infinity we will look at whether or not either bound is further out than the other. If this is the case than the most inner side will be chosen to be the representative for that bound in Z. 

If both bounds are equal then we look if they are both inclusive, if yes then Z will be inclusive too, if either one is not inclusive then Z will also be not inclusive for said bound. The value of Z will be equal to the bound of X and Y in any of these cases.

\subsubsection{Interval union}
The union operation is summarised in Figure \ref{fig:union} below. We can immediately see that this is very similar to the intersection in the sense that most of the conditional statements are the exact same. The first big difference lies in the fact that the case where there is no overlap is no longer considered. This is because firstly, considering there to be no overlap would imply that we need to support intervals with gaps. This would dramatically increase the number of variables we need and it was therefore not considered. This does not hurt our implementation in any way as it is impossible to ever obtain a split interval in case you consider every node to have one interval per preceding node, rather than one big interval. Furthermore it can never happen that we become a split interval in the case where there are no loops. We simply consider one path in which each node can only occur once, it can therefore only update the interval of each node once. A single update can never lead to multiple intervals considering that all restrictions simply restrict the bounds, and not filter out anything from the middle of the interval.

Next we once again split the evaluation into two near identical evaluations being marked by the blue and red nodes. The red segment relates to the lower bound, the blue segment to the upper bound. In case either side goes to infinity for $X$ or $Y$, $Z$ will trivially go to infinity too. In case it does not go to infinity we will select the one closes to the bounds. Finally if both bounds are equal we will by default set the boundary value equal to boundary value of $X$ and $Y$ and make it inclusive if either $X$ or $Y$ is inclusive and exclusive otherwise.

\begin{figure}
	\centering
	\begin{tikzpicture}[auto, >=latex, font=\footnotesize\scshape]
		\tikzstyle{center} = [draw=black, rectangle, text width=5.5em, align=center]
		\tikzstyle{centert} = [draw=black, rectangle, text width=5.5em, align=center, text=red]
		\tikzstyle{centerb} = [draw=black, rectangle, text width=5.5em, align=center, text=blue]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		
		\node[center]	at (0, 7) 		(q0) 	{$Z = X \cup Y$};
		\node[center]	at (0, 3.8)		(q4)	{else};
		
		\node[center]	at (1.6, 6) 	(q2) 	{X is empty};
		\node[center]	at (1.6, 5)		(q3)	{Y is empty};
		
		\node[centert]	at (1.6, 2.4)	(q6)	{$X_2 \ne 2$ $\land$ \\ $X_2 \ne 2$};
		\node[centerb]	at (1.6, -3.9)	(q7)	{$X_3 \ne 2$ $\land$ \\ $X_3 \ne 2$};
		
		\node[center]	at (4.5, 6)		(q10)	{$Z = Y$};
		\node[center]	at (4.5, 5)		(q11)	{$Z = X$};
		\node[centert]	at (4.5, 3.8)	(q12)	{$X_2/Y_2 = 2$};
		\node[center]	at (4.5, 2.4)	(q14)	{$X_0 < Y_0$};
		\node[center]	at (4.5, 1.1)	(q15)	{$Y_0 < X_0$};
		\node[center]	at (4.5, -0.2)	(q16)	{$X_0 = Y_0$};
		\node[centerb]	at (4.5, -2.6)	(q13)	{$X_3/Y_3 = 2$};
		\node[center]	at (4.5, -3.9)	(q17)	{$X_1 > Y_1$};
		\node[center]	at (4.5, -5.2)	(q18)	{$Y_1 > X_1$};
		\node[center]	at (4.5, -6.5)	(q19)	{$X_1 = Y_1$};
		
		\node[center]	at (7.5, 3.8)		(q32)	{$Z_0 = 0$ $\land$ \\ $Z_2 = 2$};
		\node[center]	at (7.5, 2.4)		(q22)	{$Z_0 = X_0$ $\land$ \\ $Z_2 = X_2$};
		\node[center]	at (7.5, 1.1)		(q23)	{$Z_0 = Y_0$ $\land$ \\ $Z_2 = Y_2$};
		\node[center]	at (7.5, -0.2)		(q25)	{$X_2 = Y_2 = 0$};
		\node[center]	at (7.5, -1.5)		(q26)	{$X_2/Y_2 = 1$};
		\node[center]	at (7.5, -2.6)		(q33)	{$Z_1 = 0$ $\land$ \\ $Z_3 = 2$};
		\node[center]	at (7.5, -3.9)		(q27)	{$Z_1 = Y_1$ $\land$ \\ $Z_3 = Y_3$};
		\node[center]	at (7.5, -5.2)		(q28)	{$Z_1 = X_1$ $\land$ \\ $Z_3 = X_3$};
		\node[center]	at (7.5, -6.5)		(q30)	{$X_3 = Y_3 = 0$};
		\node[center]	at (7.5, -7.8)		(q31)	{$X_3/Y_3 = 1$};
		
		\node[center]	at (10.5, -0.2)	 (q36)	{$Z_0 = X_0$ $\land$ \\ $Z_2 = 0$};
		\node[center]	at (10.5, -1.5)	 (q37)	{$Z_0 = X_0$ $\land$ \\ $Z_2 = 1$};
		\node[center]	at (10.5, -6.5)	 (q39)	{$Z_1 = X_1$ $\land$ \\ $Z_3 = 0$};
		\node[center]	at (10.5, -7.8) (q40)	{$Z_1 = X_1$ $\land$ \\ $Z_3 = 1$};
		
		\draw [arrow] (q0)  -- (q4);
		
		\draw [arrow] (q0)  |- (q2);
		\draw [arrow] (q0)  |- (q3);
		
		\draw [arrow] (q4)  |- (q6);
		\draw [arrow] (q4)  |- (q7);
		
		\draw [arrow] (q2)  |- (q10);
		\draw [arrow] (q3)  |- (q11);
		\draw [arrow] (q4)  |- (q12);
		\draw [arrow] (q4)  |- (q13);
		\draw [arrow] (q6)  |- (q14);
		\draw [arrow] (q6)  |- (q15);
		\draw [arrow] (q6)  |- (q16);
		\draw [arrow] (q7)  |- (q17);
		\draw [arrow] (q7)  |- (q18);
		\draw [arrow] (q7)  |- (q19);
		
		\draw [arrow] (q12) |- (q32);
		\draw [arrow] (q13) |- (q33);
		\draw [arrow] (q14) |- (q22);
		\draw [arrow] (q15) |- (q23);
		\draw [arrow] (q16) |- (q25);
		\draw [arrow] (q16) |- (q26);
		\draw [arrow] (q17) |- (q27);
		\draw [arrow] (q18) |- (q28);
		\draw [arrow] (q19) |- (q30);
		\draw [arrow] (q19) |- (q31);
		
		\draw [arrow] (q25) |- (q36);
		\draw [arrow] (q26) |- (q37);
		\draw [arrow] (q30) |- (q39);
		\draw [arrow] (q31) |- (q40);
		
	\end{tikzpicture}
	\caption{Overview of the interval union operation.}
	\label{fig:union}
\end{figure}
\subsubsection{Interval updates}
The final component is the behaviour of the intervals after initialization. This process will be similar to the $succ$ function defined for non parametric COCA but now converted to equations. For the remainder of this section we will give the equations for a transition $(p, z, q)$.

The first step will be to convert the operation of the current transition to an interval using the conversion rules below where $z$ represents the integer value of the transition operation. Notice that there is no case in which no label is present, this is because this will be automatically mapped to 0 which is needed as we will refer to this interval in further steps and it is thus required that it exists. In all further steps we will refer to this interval as $I_z$.

\begin{gather*}
	z < 0 \rightarrow I_z = (z, 0, 1, 0) \\
	z > 0 \rightarrow  I_z = (0, z, 0, 1) \\
	z = 0 \rightarrow I_z = (0, 0, 0, 0) 
\end{gather*}

Next we need to add this to the interval of the start node $p$, denoted as $I_p$ as to compute the resulting interval after the transition. The interval of $p$ will be the interval obtained in the previous step. This new interval will be referred to as $I_r$.

\begin{gather*}
	I_r = I_z + I_p
\end{gather*}

The $I_f$ interval needs to be scaled as to be conform with the automaton bounds as well as the node bounds. In the formula below the automaton bounds are represented by $I_{ab}$ and the node bounds by $I_{nb}$. The resulting bounded interval will be stored in $I_{br}$.

\begin{gather*}
	I_{br} = (I_r \cap I_{ab}) \cap I_{nb}
\end{gather*}

Finally we update the interval of the transitions end node $q$ by taking the intersection of the original interval from the previous step, $I_q$ with the newly obtained interval $I_{br}$. The interval $I_q'$ will be used as the new interval for node $q$ in the current step.

\begin{gather*}
	I_{q}' = I_{br} \cup I_q
\end{gather*}

As a condition to verify reachability we will add a constraint on $I_q'$ ensuring that it is not empty. In case $I_q'$ is empty it implies that this transition was not enabled and that node $q$ is not reachable via the chosen path.

Simply ensuring emptiness will lead to undesired behaviour in case there are transitions that can not be taken. Given the automaton in Figure \ref{fig:partially reachable} we can see that $q_2$ and $q_3$ will never be reachable. If we enforce the above it will result in no nodes being reachable as we require a path of length 3 where in the end none of the intervals are empty. This can never be true as two of the nodes will always have an empty interval.

\begin{figure}[h]%
	\centering
	\begin{tikzpicture}[auto, >=latex, node distance = 1 cm]
		\tikzstyle{round} = [thick, draw=black, circle, font=\small]
		\tikzstyle{invis} = [draw=none, font=\small]
		\tikzstyle{arrow} = [thick,->,>=stealth]
		
		\node[round] 	at (0, 0) 		(q0) 	{$q_0$};
		\node[round] 	at (3, 0)		(q1) 	{$q_1$};
		\node[invis]	at (3.7, 0.5)	(q4)	{$=1$};
		\node[round] 	at (6, 0)		(q2) 	{$q_2$};
		\node[invis]	at (6.7, 0.5)	(q4)	{$\geq 5$};
		\node[round] 	at (9, 0)		(q3) 	{$q_3$};
		\node[invis]	at (9.7, 0.5)	(q4)	{$\leq 5$};
		
		\path[->]
		(q0) 	edge 					node 					{$+1$}	(q1)
		(q1) 	edge 					node 					{$-1$}	(q2)
		(q2)	edge 					node					{$-1$}	(q3);
	\end{tikzpicture}
	\caption{Example of a partially reachable automaton.}
	\label{fig:partially reachable}
\end{figure}

To prevent this situation we will use the previously defined variable $n$ with which we can extend the previously defined formula for an interval update with the condition below.

\begin{gather*}
	i > n \lor update\_interval
\end{gather*}

The intervals that do not get update within a step will simply have their value copied to the next interval. Note that this is not necessarily needed in this case considering that we do not support loops. We could theoretically keep two intervals for each node, one interval representing the value at initialization and one interval representing the value after visiting because each node can logically only be visited once. This implementation would however heavily limit the extendability of this implementation as it would result in us never being able to add loop support. As will be discussed later in this paper there is still need for further improvements including support for loops and the option for this should therefore be left open.

\section{Tool Validation}
To determine the correctness of our tool, we created a test suite consisting out of three groups of tests, which are all white box tests. The tests will check the outputted dot and the trace output of the program, against traces and dot files which have been manually generated and verified.

The first group will only test the first loop of the program, and it will check whether or not all nodes get properly generated. This purely tests on the generation of nodes, and will not regard any variation in configuration in which these nodes could occur.

The second group will test the cleaner. It will test most cases (all common cases) in which folding and substituting should occur as well as the cases where it should not fold anything. In this group we will also perform extensive symbol table testing, to check whether or not all values get properly tracked by the symbol table.

The third group will test the full tool. It will validate the dot file resulting from the cleaner, as well as the dot file(s) resulting from the counter automaton generator. It will also evaluate all output regarding the symbol table, and the potential errors of the code validator. There are happy day tests where each conditional statement gets tested separately, there are tests where conditional statements get nested and there are tests to see whether we can still evaluate conditional statements with constant conditions. Furthermore, there are failure tests that test whether or not we can properly detect incorrect counter types, incorrect parameter types, incorrect number of counters, incorrect conditional operations, incorrect counter modifications and properly detect counters defined in global scopes. There are also tests for edge case scenarios, such as returns in every single branch, the cleaner will not be able to detect these, and therefore the generator should be able to stop generating all nodes, once there are no branch that can carry on.

The test coverage was validated using Codecov, which gave a total line coverage of 93\% at the end of development. This coverage was used as a metric to determine whether or not there were sufficient tests at each stage of development. The remaining 7\% are trivial lines that did not need any testing, such as \textit{\_\_str\_\_} operators.

\section{Conclusion}
In this paper we propose an algorithm for converting a small subset of the c language to counter automata, and discuss its implementation. The resulting automata can be used in reachability analysis within the code. 

The paper gives a description on all the steps the program goes through in order to achieve this counter automaton, as well as a brief insight in why things are the way they are.

This proposed algorithm can be used to improve existing static code analysis and will furthermore be usable to solve the halting problem for a subset of c programs. It is however only usable in a limited amount of cases, in more complex situations, where reachability analysis would be far more desired, it will most likely not be usable as chances of violated conditions will be high. In the situations where it is applicable, big conditional statements or a large amount of conditional statements can make determining the reachability of certain sub segments hard, and with the addition of this algorithm as a reachability checker, it could definitely lead to improvements in coding.

\section{Future work}
One of the future aspects that still needs to be worked on, is the precision, efficiency and usefulness of the program. The program is too restrictive to be practically usable, and should therefore be expanded to support further c code.

Furthermore, before the resulting counter automata have any use, there needs to be an expansion to the tool, which will allow the evaluation of counter automata, so that actual reachability conclusions can be made.
\printbibliography
\end{document}